############################################################################
# Script: test_iam_user_policy.py                                          #
# Author: Mark Prager (maprager@cisco.com)                                 #
# Version: 1.0                                                             #
# Date: 12 July 2018                                                       #
#                                                                          #
# Description:                                                             #
# Python Script using boto3 to access iam user policies and check if       #
# they are correct security wise. No users 'should' be given direct access #
# to wildcarded AWS resources, unless specifically given. This script      #
# find where such examples might reside.                                   #
#                                                                          #
# Environment Variables: SNSArn - containing SNSTopic to send email to     #
#                                                                          #
# Config Files:                                                            #
# Two files placed in accessable S3 buckets.                               #
# File 1: contains a user whitelist - for known users not needed to be     #
#         checked, in the form                                             #
#         { "UserWhiteList" : [ "maprager1", "maprager2", "maprager3" ]}   #
#                                                                          #
#                                                                          #
# File 2: contains a list of regular expressions of AWS resources that     #
#         should not be specified, in the form:                            #
#         { "badAwsResources" : [ "*", "arn:aws:s3:::*" ] }                #
#         Default value (if not specified) is the above                    #
#                                  ["*", "arn:aws:s3:::*" ]                #
#                                                                          #
############################################################################
from __future__ import print_function
import time
import datetime
import json
import sys
import boto3
import logging
from botocore.exceptions import ClientError
from os import environ

####################
# global variables #
####################
# File Locations
s3location='YOURS3LOCATION'
# example whitelist filename
whitelist='whitelist.json'
# example awsExpr filename
awsExpr='badAwsResourcesExpr.json'
# Globals used
reportMsg=""
usersToIgnore=[]
badAwsResourcesExpr=[]

#######################
# Set up debug messages
# Uncomment, if required
#######################
logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)
#logging.info('A info message!')
logging.debug('A debug message!')

######
## Function to send emails via sns
## Uses Environement variable SNSArn for the SNS topic.
######
def publish_sns(sns_message):
    """
    Publish message to the master SNS topic
    """
    now = datetime.datetime.now()
    today = now.strftime("%Y-%m-%d %H:%M")
    ## Remember to set up your SNSTopic in the correct region, and provide the correct region below.
    sns_client = boto3.client('sns', region_name='us-east-2')
    sns_client.publish(TargetArn=environ['SNSArn'], Message=sns_message, Subject='IAM Check User Policies ' + str(today))
    return

######
## Function to add to a report string - so can be used to send emails
## Uses global variable - reportMsg
######
def addToReport(*msgs):
    global reportMsg
    for i in msgs:
        reportMsg = reportMsg + str(i) + " "
    reportMsg += "\n"
    return


######
## Function to handle the report generated by the script
######
def reportHandler():
    global reportMsg
    #print (reportMsg)
    publish_sns(reportMsg)
    return
######

######
## Function to check the policy - this is the part doing the actual work
######
def checkPolicy(entity,policyname,userpolicy):
   global badAwsResourcesExpr
   for part in userpolicy:
       ## Part of the resource policy can be a string
       if isinstance(part['Resource'],basestring):
	   if part['Resource'] in badAwsResourcesExpr and part['Effect'] == "Allow":
		 addToReport (entity, "Bad user policy:, Resource: (allow)", part['Resource'], policyname )
       ## Or it can be a list
       if type(part['Resource']) is list:
	   if part['Resource'][0] in badAwsResourcesExpr and part['Effect'] == "Allow":
		 addToReport (entity, "Bad user policy:, Resource: (allow)", part['Resource'], policyname )
   return

#####
## Function to read a Json file from a bucket
#####
def readBucketFileJson(bucketName,filename):
    s3client = boto3.client('s3')

    for obj in s3client.list_objects(Bucket = bucketName)['Contents']:
      if filename in obj['Key']:
         infile = s3client.get_object(Bucket = bucketName, Key = obj['Key'])
         fileData = infile['Body'].read()
         jsonData = json.loads(fileData)
         return(jsonData)

#####
## Function to check a group policy that is attached to a user
#####
def check_policy_of_group(username, iamgroup):
         # Check Attached inline policy
         logging.debug("Checking inline policy of Group: "+iamgroup)

         myiam=boto3.resource("iam")
         group=myiam.Group(iamgroup)

         logging.debug (group.policies.all())
         for j in group.policies.all():
              checkPolicy("USER: "+username+" attached to GROUP: "+iamgroup+" [inline policy] ",j.policy_name,j.policy_document['Statement'])

         # Now Check any Attached policys (to the group)
         logging.debug("Checking attached policy of Group: "+iamgroup)
         mypolicy=group.attached_policies.all()
         for k in mypolicy:
              checkPolicy("USER: "+username+" attached to GROUP: "+iamgroup+" [attached policy] ", k.policy_name,k.default_version.document['Statement'])

         return

#####
## Function to read in the config files
## Note: the S3 location and filenames at the function start
#####
def readInConfigFiles():
     ### File locations
     global s3location
     global whitelist
     global awsExpr
     global usersToIgnore
     global badAwsResourcesExpr

     ## attempt to read user whitelist
     try:
         usersToIgnore=readBucketFileJson(s3location, whitelist)
         logging.debug (usersToIgnore)
         for user in usersToIgnore['UserWhitelist']:
            logging.debug (user)
     except:
         # no whitelist
         pass
     logging.debug (usersToIgnore)
     
     ## attempt to read the bad AWS resources Expression from S3 file
     try:
         myBadAwsResourcesExpr=readBucketFileJson(s3location,awsExpr)
         for exp in myBadAwsResourcesExpr['badAwsResources']:
            badAwsResourcesExpr += exp
     except:
         pass
     logging.debug (badAwsResourcesExpr)
     
     ### Default Value if none set
     if badAwsResourcesExpr == []:
         badAwsResourcesExpr=["*","arn:aws:s3:::*"]

     logging.debug (badAwsResourcesExpr,usersToIgnore)
     return

#####
## The Function that iterates over all the users in the account.
#####
def checkTheUsers():
  global userToIgnore
  # Start a boto client
  iam=boto3.client("iam")
  for userlist in iam.list_users()['Users']:
        user_name=userlist['UserName']

        logging.debug ("---- Start Checking user: "+user_name+" -----")

        ### Ignore users in the whitelist
        if user_name not in usersToIgnore['UserWhitelist']:

            ## First check inline_user_policy:
            inline_user_policies = iam.list_user_policies(UserName=user_name)
            policy=inline_user_policies['PolicyNames']
            if len(policy) != 0:
                logging.debug("Username: "  + user_name + " uses inline policy:")
                for pol in policy:
                   ### This part will only be reached if there is an inline policy
                   userpolicy=iam.get_user_policy(UserName=user_name, PolicyName=pol)['PolicyDocument']['Statement']
                   logging.debug (json.dumps(userpolicy,indent=4, sort_keys=True),pol)
                   checkPolicy("USER: "+user_name+ " [inline policy] ", pol, userpolicy)
                   logging.debug("----- End Check inline -----")
            else:
                logging.debug("Username: "  + user_name + " might use groups .. checking")
                ## Check if user is attached to a group (most normal case)
                userGroups = iam.list_groups_for_user(UserName=user_name)
                logging.debug("Assigned groups: ")
                for groupName in userGroups['Groups']:
                    check_policy_of_group(user_name,groupName['GroupName'])
                    logging.debug("----- End Check attached groups ----- ")

                ## user can also have an attached policy
                logging.debug("Username: "  + user_name + " might use policies .. checking")
                userPolicies = iam.list_attached_user_policies(UserName=user_name)
                logging.debug ("Assigned policies: ")
                for policy in userPolicies['AttachedPolicies']:
                   logging.debug (policy['PolicyName'],policy['PolicyArn'])
                   pol=iam.get_policy( PolicyArn = policy['PolicyArn'])
                   ## Get Policy Version
                   policyVersion= iam.get_policy_version(PolicyArn=policy['PolicyArn'],VersionId=pol['Policy']['DefaultVersionId'])
                   userpolicy=(policyVersion['PolicyVersion']['Document']['Statement'])
                   logging.debug (json.dumps(userpolicy,indent=4, sort_keys=True),pol)
                   checkPolicy("USER: "+user_name + " [attached policy] " , pol,userpolicy)
                   logging.debug("----- End Check attached policy ----- ")

        else:
          logging.debug ("User in whitelist, skipping")
        logging.debug ("---- End   Checking user: "+user_name+" -----")

  return

def lambda_handler(event, context):
    ### MAIN ###
    readInConfigFiles()
    checkTheUsers()
    reportHandler()
    return 'End Lambda Function'
